// Code generated by goagen v1.1.0-dirty, command line:
// $ goagen
// --design=gorilla_fan/design
// --out=$(GOPATH)/src/gorilla_fan
// --version=v1.0.0
//
// API "gorilla_fan": Application Contexts
//
// The content of this file is auto-generated, DO NOT MODIFY

package app

import (
	"github.com/goadesign/goa"
	"golang.org/x/net/context"
	"net/http"
	"strconv"
)

// ListFanContext provides the fan list action context.
type ListFanContext struct {
	context.Context
	*goa.ResponseData
	*goa.RequestData
}

// NewListFanContext parses the incoming request URL and body, performs validations and creates the
// context used by the fan controller list action.
func NewListFanContext(ctx context.Context, r *http.Request, service *goa.Service) (*ListFanContext, error) {
	var err error
	resp := goa.ContextResponse(ctx)
	resp.Service = service
	req := goa.ContextRequest(ctx)
	req.Request = r
	rctx := ListFanContext{Context: ctx, ResponseData: resp, RequestData: req}
	return &rctx, err
}

// OK sends a HTTP response with status code 200.
func (ctx *ListFanContext) OK(r GorillaFanCollection) error {
	ctx.ResponseData.Header().Set("Content-Type", "application/vnd.gorilla.fan+json; type=collection")
	if r == nil {
		r = GorillaFanCollection{}
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 200, r)
}

// NotFound sends a HTTP response with status code 404.
func (ctx *ListFanContext) NotFound() error {
	ctx.ResponseData.WriteHeader(404)
	return nil
}

// ShowFanContext provides the fan show action context.
type ShowFanContext struct {
	context.Context
	*goa.ResponseData
	*goa.RequestData
	FanID int
}

// NewShowFanContext parses the incoming request URL and body, performs validations and creates the
// context used by the fan controller show action.
func NewShowFanContext(ctx context.Context, r *http.Request, service *goa.Service) (*ShowFanContext, error) {
	var err error
	resp := goa.ContextResponse(ctx)
	resp.Service = service
	req := goa.ContextRequest(ctx)
	req.Request = r
	rctx := ShowFanContext{Context: ctx, ResponseData: resp, RequestData: req}
	paramFanID := req.Params["fanID"]
	if len(paramFanID) > 0 {
		rawFanID := paramFanID[0]
		if fanID, err2 := strconv.Atoi(rawFanID); err2 == nil {
			rctx.FanID = fanID
		} else {
			err = goa.MergeErrors(err, goa.InvalidParamTypeError("fanID", rawFanID, "integer"))
		}
	}
	return &rctx, err
}

// OK sends a HTTP response with status code 200.
func (ctx *ShowFanContext) OK(r *GorillaFan) error {
	ctx.ResponseData.Header().Set("Content-Type", "application/vnd.gorilla.fan+json")
	return ctx.ResponseData.Service.Send(ctx.Context, 200, r)
}

// NotFound sends a HTTP response with status code 404.
func (ctx *ShowFanContext) NotFound() error {
	ctx.ResponseData.WriteHeader(404)
	return nil
}

// TurnFanContext provides the fan turn action context.
type TurnFanContext struct {
	context.Context
	*goa.ResponseData
	*goa.RequestData
	FanID   string
	Payload *FanPayload
}

// NewTurnFanContext parses the incoming request URL and body, performs validations and creates the
// context used by the fan controller turn action.
func NewTurnFanContext(ctx context.Context, r *http.Request, service *goa.Service) (*TurnFanContext, error) {
	var err error
	resp := goa.ContextResponse(ctx)
	resp.Service = service
	req := goa.ContextRequest(ctx)
	req.Request = r
	rctx := TurnFanContext{Context: ctx, ResponseData: resp, RequestData: req}
	paramFanID := req.Params["fanID"]
	if len(paramFanID) > 0 {
		rawFanID := paramFanID[0]
		rctx.FanID = rawFanID
	}
	return &rctx, err
}

// OK sends a HTTP response with status code 200.
func (ctx *TurnFanContext) OK(r *GorillaFan) error {
	ctx.ResponseData.Header().Set("Content-Type", "application/vnd.gorilla.fan+json")
	return ctx.ResponseData.Service.Send(ctx.Context, 200, r)
}

// BadRequest sends a HTTP response with status code 400.
func (ctx *TurnFanContext) BadRequest(r error) error {
	ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	return ctx.ResponseData.Service.Send(ctx.Context, 400, r)
}

// ListThermoContext provides the thermo list action context.
type ListThermoContext struct {
	context.Context
	*goa.ResponseData
	*goa.RequestData
}

// NewListThermoContext parses the incoming request URL and body, performs validations and creates the
// context used by the thermo controller list action.
func NewListThermoContext(ctx context.Context, r *http.Request, service *goa.Service) (*ListThermoContext, error) {
	var err error
	resp := goa.ContextResponse(ctx)
	resp.Service = service
	req := goa.ContextRequest(ctx)
	req.Request = r
	rctx := ListThermoContext{Context: ctx, ResponseData: resp, RequestData: req}
	return &rctx, err
}

// OK sends a HTTP response with status code 200.
func (ctx *ListThermoContext) OK(r GorillaThermoCollection) error {
	ctx.ResponseData.Header().Set("Content-Type", "application/vnd.gorilla.thermo+json; type=collection")
	if r == nil {
		r = GorillaThermoCollection{}
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 200, r)
}

// NotFound sends a HTTP response with status code 404.
func (ctx *ListThermoContext) NotFound() error {
	ctx.ResponseData.WriteHeader(404)
	return nil
}

// SetlimitsThermoContext provides the thermo setlimits action context.
type SetlimitsThermoContext struct {
	context.Context
	*goa.ResponseData
	*goa.RequestData
	ThermoID string
	Payload  *ThermoPayload
}

// NewSetlimitsThermoContext parses the incoming request URL and body, performs validations and creates the
// context used by the thermo controller setlimits action.
func NewSetlimitsThermoContext(ctx context.Context, r *http.Request, service *goa.Service) (*SetlimitsThermoContext, error) {
	var err error
	resp := goa.ContextResponse(ctx)
	resp.Service = service
	req := goa.ContextRequest(ctx)
	req.Request = r
	rctx := SetlimitsThermoContext{Context: ctx, ResponseData: resp, RequestData: req}
	paramThermoID := req.Params["thermoID"]
	if len(paramThermoID) > 0 {
		rawThermoID := paramThermoID[0]
		rctx.ThermoID = rawThermoID
	}
	return &rctx, err
}

// OK sends a HTTP response with status code 200.
func (ctx *SetlimitsThermoContext) OK(r *GorillaThermo) error {
	ctx.ResponseData.Header().Set("Content-Type", "application/vnd.gorilla.thermo+json")
	return ctx.ResponseData.Service.Send(ctx.Context, 200, r)
}

// BadRequest sends a HTTP response with status code 400.
func (ctx *SetlimitsThermoContext) BadRequest(r error) error {
	ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	return ctx.ResponseData.Service.Send(ctx.Context, 400, r)
}

// NotFound sends a HTTP response with status code 404.
func (ctx *SetlimitsThermoContext) NotFound() error {
	ctx.ResponseData.WriteHeader(404)
	return nil
}

// ShowThermoContext provides the thermo show action context.
type ShowThermoContext struct {
	context.Context
	*goa.ResponseData
	*goa.RequestData
	ThermoID string
}

// NewShowThermoContext parses the incoming request URL and body, performs validations and creates the
// context used by the thermo controller show action.
func NewShowThermoContext(ctx context.Context, r *http.Request, service *goa.Service) (*ShowThermoContext, error) {
	var err error
	resp := goa.ContextResponse(ctx)
	resp.Service = service
	req := goa.ContextRequest(ctx)
	req.Request = r
	rctx := ShowThermoContext{Context: ctx, ResponseData: resp, RequestData: req}
	paramThermoID := req.Params["thermoID"]
	if len(paramThermoID) > 0 {
		rawThermoID := paramThermoID[0]
		rctx.ThermoID = rawThermoID
	}
	return &rctx, err
}

// OK sends a HTTP response with status code 200.
func (ctx *ShowThermoContext) OK(r *GorillaThermo) error {
	ctx.ResponseData.Header().Set("Content-Type", "application/vnd.gorilla.thermo+json")
	return ctx.ResponseData.Service.Send(ctx.Context, 200, r)
}

// NotFound sends a HTTP response with status code 404.
func (ctx *ShowThermoContext) NotFound() error {
	ctx.ResponseData.WriteHeader(404)
	return nil
}
